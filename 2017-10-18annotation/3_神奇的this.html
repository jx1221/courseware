<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    /*
        this:
            window
            事件触发元素
            对象
            undefined
            父级
            写啥是啥

        只要在函数中，有可能被修改

        先看是函数还是方法，如果是方法，那么this基本上是寄主。
        如果是函数，那么基本上是window
            
    */

    // function fn(){
    //     console.log(this);
    // }
    //fn(); //window


    //document.onclick =fn;//点击之后在执行
    
    // function fn(){
    //     console.log(this);// document
    // }

    //document.onclick =fn();//刷新之后直接执行
        
    // function fn(){
    //     console.log(this);// window
    // }

    // document.onclick = function(){
    //     // console.log(this); document

    //     // function fn(){
    //     //     console.log(this); //window
    //     // }
    //     // fn();

    //     (function(){
    //         console.log(this);//window
    //     })();
    // }

    // document.onclick = (function(){
    //     console.log(this); //window
    //     return function(){
    //         console.log(this);//document
    //     }
    // })();

    // document.onclick = fn();//刷新之后自己直接执行了
    // function fn(){
    //     console.log(this); //window
    // }

    // document.onclick = new fn();//new了之后自己执行了，然后this的指向就变为fn{}
    // function fn(){
    //     console.log(this); //fn{}
    // }
    
    // document.onclick = function(){
    //     function fn1(){
    //         console.log(this);//new了之后这函数自己执行了，然后此处this是fn1{}，然后这个还能输返回了一个函数
    //         return function(){//再进行第二次new的时候，new的是一个匿名函数，那么返回的值为Object
    //             console.log(this);此时的this就是object
    //         }
    //     }
    //     new new fn1; //函数才能new
    // }

    // document.onclick = function(){
    //     function fn1(){
    //         return function(){
    //            setTimeout(function(){
    //              console.log(this); //window，因为这里是定时器，定时器里的东西都是window直接调用的
    //            });
    //         }
    //     }
    //     new new fn1;
    // }

   //  var arr = [];
   //  arr.fn = function(){
   //      function fn1(){
   //          return function(){
   //              console.log(this); //Object，此处答案同上
   //          }
   //      }
   //      new new fn1;
   //  }
   // new arr.fn;//让整个方法执行

    var obj = {
        name:'nizp',
        fn:function(){
           console.log(this.name); // C 这个地方的this是window，然后window的name就是为空
        }
    }
    setTimeout(obj.fn,1000);

    console.dir(window);

    /*
        A:nizp  B:undefined C:'' D:null  E:报错
    */
    

</script>
</body>
</html>